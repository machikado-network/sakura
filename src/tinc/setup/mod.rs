use crate::utils::run_command_and_wait;
use colored::*;
use std::fs;
use std::io::Write;
use std::net::Ipv4Addr;
use std::process::{exit, Command};
use std::str::FromStr;

#[macro_export]
macro_rules! info {
    ( $x:expr ) => {
        $x.bright_green().bold()
    };
}

macro_rules! error {
    ( $x:expr ) => {
        $x.bright_red().bold()
    };
}

const NAT_SETTING: &str = "\
# Generated by xtables-save v1.8.2 on Thu Jul 15 00:21:02 2021
*filter
:INPUT ACCEPT [46687:11733996]
:FORWARD ACCEPT [1617:74797]
:OUTPUT ACCEPT [295135:228581507]
-A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT
-A FORWARD -m state --state RELATED,ESTABLISHED -j ACCEPT
-A FORWARD -i {interface} -o eth0 -j DROP
COMMIT
# Completed on Thu Jul 15 00:21:02 2021
# Generated by xtables-save v1.8.2 on Thu Jul 15 00:21:02 2021
*nat
:PREROUTING ACCEPT [15990:4356696]
:INPUT ACCEPT [12944:3533125]
:POSTROUTING ACCEPT [410:45315]
:OUTPUT ACCEPT [175:24583]
-A POSTROUTING -o {interface} -j MASQUERADE
COMMIT
# Completed on Thu Jul 15 00:21:02 2021
# Generated by xtables-save v1.8.2 on Thu Jul 15 00:21:02 2021
*mangle
:PREROUTING ACCEPT [0:0]
:INPUT ACCEPT [0:0]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
:POSTROUTING ACCEPT [0:0]
COMMIT
# Completed on Thu Jul 15 00:21:02 2021
# Generated by xtables-save v1.8.2 on Thu Jul 15 00:21:02 2021
*raw
:PREROUTING ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
COMMIT
# Completed on Thu Jul 15 00:21:02 2021
";

const TINC_DOWN: &str = "\
#!/bin/sh
ip link set dev $INTERFACE nomaster
ip link set dev $INTERFACE down
#ip link set dev eth1 nomaster
ip link set dev {interface} down
ip link del dev {interface}
";

pub fn validate_name(s: &str) -> Result<String, String> {
    if s.len() > 32 {
        return Err("Names must be 32 characters or less.".to_string());
    }
    if s.is_empty() {
        return Err("Names must be 1 characters or more".to_string());
    }
    for char in s.chars() {
        if char.is_ascii_digit() {
            continue;
        }
        match char {
            'a'..='z' => continue,
            '0'..='9' => continue,
            _ => return Err("You can use [0-9a-z] to name.".to_string()),
        }
    }
    Ok(s.to_string())
}

pub fn validate_ip_addr(s: &str) -> Result<Ipv4Addr, String> {
    let r = Ipv4Addr::from_str(s);
    if r.is_err() {
        return Err("Invalid IP address syntax".to_string());
    }
    let addr = r.unwrap();

    match addr.octets() {
        [a, b, _, _] if a != 10 || b != 50 => Err("IP address must be in 10.50.0.0/16".to_string()),
        [_, _, c, d] if c == 0 || d == 0 => Err("Subnet ID must be from 1 to 255.".to_string()),
        _ => Ok(addr),
    }
}

fn check_interface_used(interface: String) {
    println!("    {} bridge interface {} is used", info!("Checking"), info!(interface));
    let output = Command::new("ip")
        .args(&["link", "show", interface.as_str()])
        .output()
        .expect(&*format!("Failed to run `ip link show {}`", interface));
    if output.status.success() {
        println!("    {} bridge interface {}. abort.", error!("Found"), info!(interface));
        exit(1);
    }
    println!("    Bridge interface not found!");
}

pub fn setup_tinc(name: String, ip_addr: Ipv4Addr, interface: String) {
    println!(
        "    {}",
        "Starting setup tinc node for Machikado Network"
            .bright_green()
            .bold()
    );
    check_machikado_network_installed();
    println!();
    check_interface_used(interface.clone());
    println!();
    install_tinc();
    println!();
    println!(
        "    {} Machikado Network Config Directory to {}",
        info!("Creating"),
        info!("/etc/tinc/mchkd")
    );
    create_directories();
    println!();
    create_node_file(name.clone());
    println!();
    create_tinc_conf(name.clone());
    println!();
    create_tinc_up(ip_addr, interface.clone());
    println!();
    create_nat_iptables(interface.clone());
    println!();
    create_tinc_down(interface);
    println!();
    println!("    {} RSA Key Pair", info!("Generating"));
    let output = Command::new("tincd")
        .args(&["-K", "-n", "mchkd"])
        .output()
        .expect("Failed to run `which tincd`");
    println!("{}", String::from_utf8_lossy(&output.stdout));
    println!("    {} debug log setting", info!("Changing"));
    run_command_and_wait(
        "sed",
        &["-i", "-e", "/^# EXTRA=\"-d\"$/ s/# //", "/etc/default/tinc"],
    );
    println!("    {} service tinc@mchkd.service", info!("Enable"));
    run_command_and_wait("systemctl", &["enable", "tinc@mchkd.service"]);
    println!("    {} service tinc@mchkd.service", info!("Starting"));
    run_command_and_wait("systemctl", &["start", "tinc@mchkd.service"]);
    println!();
    println!("{}", "==== Setup Completed! ====".bright_cyan().bold());
    println!(
        "Paste following RSA Public Key to https://machikado.network/user \"公開鍵\" section."
    );
    println!("{}", get_public_key(name).as_str().bright_yellow());
}

fn get_public_key(name: String) -> String {
    fs::read_to_string(format!("/etc/tinc/mchkd/hosts/{}", name)).unwrap()
}

fn create_tinc_down(interface: String) {
    println!("    {} /etc/tinc/mchkd/tinc-down", info!("Creating"));
    let mut file = fs::File::create("/etc/tinc/mchkd/tinc-down").unwrap();
    file.write_all(TINC_DOWN.replace("{interface}", interface.as_str()).as_bytes()).unwrap();

    println!(
        "    {} `chmod +x /etc/tinc/mchkd/tinc-down`",
        info!("Running")
    );
    run_command_and_wait("chmod", &["+x", "/etc/tinc/mchkd/tinc-down"]);
}

fn create_nat_iptables(interface: String) {
    println!("    {} /etc/tinc/mchkd/nat.iptables", info!("Creating"),);
    let mut file = fs::File::create("/etc/tinc/mchkd/nat.iptables").unwrap();
    file.write_all(NAT_SETTING.replace("{interface}", interface.as_str()).as_bytes()).unwrap();
}

fn create_tinc_up(ip_addr: Ipv4Addr, interface: String) {
    println!("    {} /etc/tinc/mchkd/tinc-up", info!("Creating"),);
    let mut file = fs::File::create("/etc/tinc/mchkd/tinc-up").unwrap();
    let content = format!(
        "#!/bin/sh\n\
        ip link add {interface} type bridge\n\
        ip link set {interface} up\n\
        ip link set $INTERFACE up\n\
        ip link set dev $INTERFACE master {interface}\n\
        #ip link set dev eth1 master {interface}\n\
        ip addr add {ip_addr}/8 dev {interface}\n\
        echo 1 > /proc/sys/net/ipv4/ip_forward\n\
        iptables-restore < /etc/tinc/mchkd/nat.iptables\n\
        ",
    );
    file.write_all(content.as_bytes()).unwrap();

    println!(
        "    {} `chmod +x /etc/tinc/mchkd/tinc-up`",
        info!("Running")
    );
    run_command_and_wait("chmod", &["+x", "/etc/tinc/mchkd/tinc-up"]);
}

fn create_tinc_conf(name: String) {
    println!("    {} /etc/tinc/mchkd/tinc.conf", info!("Creating"),);
    let mut file = fs::File::create("/etc/tinc/mchkd/tinc.conf").unwrap();
    let content = format!(
        "Name = {name}\n\
        Mode = switch\n\
        Device = /dev/net/tun\n"
    );
    println!("{}", content);
    file.write_all(content.as_bytes()).unwrap();
}

fn create_node_file(name: String) {
    println!("    {} /etc/tinc/mchkd/{}", info!("Creating"), name);
    let mut file = fs::File::create(format!("/etc/tinc/mchkd/hosts/{}", name)).unwrap();
    file.write_all(format!("# {}\n", name).as_bytes()).unwrap();
}

fn create_directories() {
    println!(
        "    {} `mkdir /etc/tinc/mchkd /etc/tinc/mchkd/hosts`",
        info!("Running")
    );
    run_command_and_wait("mkdir", &["/etc/tinc/mchkd", "/etc/tinc/mchkd/hosts"])
}

fn check_machikado_network_installed() {
    let output = Command::new("test")
        .args(&["-d", "/etc/tinc/mchkd"])
        .output()
        .expect("Failed to run `test -d /etc/tinc/mchkd`");
    if output.status.success() {
        println!("    {} /etc/tinc/mchkd is already exists. If you want to continue, you have to run `rm -d /etc/tinc/mchkd`.", error!("Error"))
    }
}

fn install_tinc() {
    #[cfg(target_os = "linux")]
    let method = "apt";
    #[cfg(target_os = "macos")]
    let method = "homebrew";
    println!(
        "    {} tinc and iptables by {}",
        "Installing".bright_green().bold(),
        method
    );

    #[cfg(target_os = "macos")]
    let r = Command::new("brew")
        .args(&["install", "tinc"])
        .spawn()
        .expect(&*format!(
            "{} {}",
            "Failed".bright_red().bold(),
            "to run `brew install tinc`"
        ));
    #[cfg(target_os = "linux")]
    let r = Command::new("apt-get")
        .args(&["install", "tinc", "iptables", "-y"])
        .spawn()
        .expect(&*format!(
            "{} {}",
            "Failed".bright_red().bold(),
            "to run `brew install tinc`"
        ));

    let output = r.wait_with_output();
    if output.is_err() || !output.unwrap().status.success() {
        println!(
            "    {} when installing tinc. abort.",
            "Error".bright_red().bold(),
        );
        exit(1);
    }
    let output = Command::new("which")
        .args(&["tincd"])
        .output()
        .expect("Failed to run `which tincd`");
    println!(
        "    {} tinc to: {}",
        "Installed".bright_green().bold(),
        String::from_utf8_lossy(&*output.stdout)
    );
}

#[cfg(test)]
mod tests {
    use super::{validate_ip_addr, validate_name};

    #[test]
    fn test_validate_name() {
        assert!(validate_name("sumidora").is_ok());
        assert!(validate_name("").is_err());
        assert!(validate_name("sumidora123").is_ok());
        assert!(validate_name("Sumidora").is_err());
        assert!(validate_name("sumidorasumidorasumidorasumidoraextra").is_err());
    }

    #[test]
    fn test_validate_ip_addr() {
        assert!(validate_ip_addr("10.50.1.1").is_ok());
        assert!(validate_ip_addr("11.50.0.1").is_err());
        assert!(validate_ip_addr("10.50.0.1").is_err());
        assert!(validate_ip_addr("10.50.1.0").is_err());
    }
}
